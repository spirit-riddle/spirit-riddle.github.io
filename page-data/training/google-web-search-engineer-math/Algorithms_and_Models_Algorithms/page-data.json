{"componentChunkName":"component---src-templates-markdown-template-js","path":"/training/google-web-search-engineer-math/Algorithms_and_Models_Algorithms/","result":{"data":{"markdownRemark":{"html":"<h1>Algorithms and Models</h1>\n<h2>Search Algorithms</h2>\n<ol>\n<li><strong>Binary Search</strong>: Efficiently finds the position of a target element in a sorted array. Commonly used in database queries and search engines.</li>\n<li><strong>Linear Search</strong>: Iterates through elements to find a target. Suitable for unsorted or small datasets.</li>\n<li><strong>Exponential Search</strong>: Extends binary search to unbounded or infinite arrays. Used in specific mathematical and computational problems.</li>\n</ol>\n<hr>\n<h2>Sorting Algorithms</h2>\n<ol>\n<li><strong>QuickSort</strong>: Divides and conquers by partitioning the array and sorting subarrays. Preferred for its average-case efficiency in large datasets.</li>\n<li><strong>MergeSort</strong>: Recursively divides the array, sorts, and merges. Common in external sorting and parallel processing.</li>\n<li><strong>HeapSort</strong>: Builds a heap structure to sort elements. Often used in real-time systems and priority queues.</li>\n<li><strong>Insertion Sort</strong>: Builds the sorted array one element at a time. Useful for small or nearly sorted datasets.</li>\n<li><strong>Bubble Sort</strong>: Repeatedly swaps adjacent elements in incorrect order. Simple but inefficient for large datasets.</li>\n</ol>\n<hr>\n<h2>Dynamic Programming Techniques</h2>\n<ol>\n<li><strong>Knapsack Problem Algorithm</strong>: Solves optimization problems by dividing them into subproblems. Used in resource allocation and finance.</li>\n<li><strong>Floyd-Warshall Algorithm</strong>: Finds shortest paths between all pairs of nodes. Useful in routing and navigation.</li>\n<li><strong>Longest Common Subsequence (LCS)</strong>: Finds the longest sequence common to two strings. Applied in DNA analysis and text comparison.</li>\n<li><strong>Matrix Chain Multiplication</strong>: Optimizes the cost of multiplying matrices. Foundational in computational mathematics.</li>\n</ol>\n<hr>\n<h2>Divide-and-Conquer Methods</h2>\n<ol>\n<li><strong>Binary Search Tree Algorithms</strong>: Splits data into halves for efficient searching. Used in database indexing.</li>\n<li><strong>Karatsuba Multiplication</strong>: Multiplies large numbers more efficiently than traditional methods. Foundational in cryptography and computational math.</li>\n<li><strong>Strassen’s Algorithm</strong>: Multiplies matrices faster than standard algorithms. Essential in computational mathematics and graphics.</li>\n<li><strong>Closest Pair of Points</strong>: Finds the closest pair of points in a plane. Applied in computational geometry.</li>\n</ol>\n<hr>\n<h2>Greedy Algorithms</h2>\n<ol>\n<li><strong>Prim’s Algorithm</strong>: Finds the Minimum Spanning Tree (MST) by adding edges with the smallest weight. Used in network design.</li>\n<li><strong>Kruskal’s Algorithm</strong>: Builds the MST by sorting edges by weight and avoiding cycles. Ideal for sparse graphs.</li>\n<li><strong>Huffman Coding</strong>: Compresses data efficiently. Foundational in data compression techniques.</li>\n</ol>\n<hr>\n<h2>Backtracking Algorithms</h2>\n<ol>\n<li><strong>N-Queens Problem</strong>: Places N queens on a chessboard such that no two threaten each other. Classic example of constraint satisfaction.</li>\n<li><strong>Sudoku Solver</strong>: Solves Sudoku puzzles using backtracking. Popular in game design and AI.</li>\n<li><strong>Hamiltonian Path and Cycle</strong>: Finds paths or cycles that visit every vertex exactly once. Applied in routing and optimization problems.</li>\n</ol>\n<hr>\n<h2>String Matching Algorithms</h2>\n<ol>\n<li><strong>Knuth-Morris-Pratt (KMP)</strong>: Finds occurrences of a pattern in a text efficiently. Used in text editors and search functions.</li>\n<li><strong>Rabin-Karp Algorithm</strong>: Uses hashing to find patterns in a string. Ideal for plagiarism detection and DNA sequencing.</li>\n<li><strong>Boyer-Moore Algorithm</strong>: Skips sections of the text to speed up pattern matching. Applied in text processing.</li>\n</ol>\n<hr>\n<h2>Numerical Methods</h2>\n<ol>\n<li><strong>Newton-Raphson Method</strong>: Approximates roots of equations. Foundational in numerical analysis and optimization.</li>\n<li><strong>Gaussian Elimination</strong>: Solves systems of linear equations. Core to linear algebra and computer graphics.</li>\n<li><strong>Gradient Descent</strong>: Optimizes functions iteratively. Widely used in machine learning.</li>\n</ol>\n<hr>\n<h2>Randomized Algorithms</h2>\n<ol>\n<li><strong>Quicksort (Random Pivot)</strong>: Enhances Quicksort by randomizing the pivot selection. Ensures balanced partitions on average.</li>\n<li><strong>Monte Carlo Algorithm</strong>: Uses randomness to approximate solutions. Foundational in probabilistic analysis.</li>\n<li><strong>Las Vegas Algorithm</strong>: Uses randomness but always produces correct results. Applied in randomized primality testing.</li>\n</ol>\n<hr>\n<h2>Graph-Based Models</h2>\n<ol>\n<li><strong>PageRank Algorithm</strong>: Ranks web pages based on their links. Core to search engines.</li>\n<li><strong>Markov Chains</strong>: Models state transitions in probabilistic systems. Used in finance, AI, and queueing theory.</li>\n<li><strong>Hidden Markov Models (HMMs)</strong>: Models systems with hidden states. Foundational in speech recognition and bioinformatics.</li>\n</ol>","frontmatter":{"title":""}}},"pageContext":{"slug":"google-web-search-engineer-math/Algorithms_and_Models_Algorithms"}},"staticQueryHashes":[],"slicesMap":{}}